## Jila API Backend – Data Models (Canonical) (v0.1)

This document defines the **exact database models** for v1: tables, columns, enums, constraints, and indexes.

Source references:
- `docs/architecture/jila_api_backend_architecture_v_0 (3).md` (domain model + invariants)
- `docs/architecture/jila_api_backend_erd.md` (relationship overview)

Notes:
- This is written in **PostgreSQL-oriented** terms.
- Geo fields use **PostGIS** (`geography`) (see decision **D-006**).
- Use `timestamptz` everywhere timestamps are stored.

Single source of truth rule (anti-drift):
- This file is the **only canonical** definition of database tables/enums/constraints.
- Other architecture docs may describe **invariants and behavior**, but must not restate full table schemas (columns/constraints) except by reference to this file.

---

## 1. Shared conventions

### 1.1 Column conventions
- **IDs**: `uuid` primary keys for entity tables, except `reservoir_readings.id` as `bigint` (append-only time series).
- **Timestamps**:
  - `created_at`, `updated_at` are `timestamptz not null` for mutable entities.
  - All timestamps generated by Jila services are **UTC** (see decision D-011).
  - `received_at` is the server receive time (UTC) for device-ingested telemetry.
  - `recorded_at` is the canonical event time used for ordering/computation; for device telemetry it is derived from `received_at` (UTC) (see decision D-011), and is distinct from `created_at`.
- **JSON**: `jsonb` used only for explicitly non-authoritative metadata/attributes.

### 1.2 Geo conventions
- `geography(Point, 4326)` for points.
- `geography(Polygon, 4326)` for zone geometry (optional).

---

## 2. Enums (canonical sets)

### 2.1 `user_status`
- `PENDING_VERIFICATION`
- `ACTIVE`
- `LOCKED`
- `DISABLED`

### 2.3 `principal_type`
- `USER`
- `ORGANIZATION`

### 2.3.1 `site_type`
- `WATER_TREATMENT`
- `PUMPING_STATION`
- `DISTRIBUTION_NODE`
- `STORAGE_RESERVOIR`
- `BOREHOLE`
- `KIOSK`
- `DEPOT`
- `HOSPITAL`
- `SCHOOL`
- `TELECOM_SITE`
- `INDUSTRIAL_SITE`
- `OTHER`

### 2.4 `access_grant_object_type`
- `ORG`
- `SITE`
- `RESERVOIR`
- `SUPPLY_POINT`
- `ORDER`
- `DEVICE`

### 2.5 `access_grant_status`
- `ACTIVE`
- `REVOKED`

### 2.6 `token_type`
- `VERIFY_PHONE`
- `VERIFY_EMAIL`
- `PASSWORD_RESET`
- `INVITE`
- `ACCOUNT_ERASURE`

### 2.7 `site_status` (if needed later)
- Not required in v1 (omit unless we introduce it).

### 2.8 `reservoir_type`
- `TANK`
- `TRUCK_TANK`
- `BUFFER_TANK`
- `OTHER`

### 2.9 `reservoir_mobility`
- `FIXED`
- `MOBILE`

### 2.10 `monitoring_mode`
- `MANUAL`
- `DEVICE`

### 2.11 `seller_availability_status`
- `AVAILABLE`
- `UNAVAILABLE`
- `UNKNOWN`

### 2.13 `device_status`
- `ACTIVE`
- `INACTIVE`
- `DECOMMISSIONED`

### 2.13.1 `device_type`
- `LEVEL_SENSOR`
- `FLOW_METER`
- `PRESSURE_GAUGE`
- `PUMP_CONTROLLER`
- `OTHER`

### 2.14 `reading_source`
- `DEVICE`
- `MANUAL`

### 2.15 `supply_point_kind`
- `STANDPIPE`
- `RIVER`
- `BOREHOLE`
- `KIOSK`
- `DEPOT`
- `OTHER`

### 2.16 `evidence_type`
- `REPORTED`
- `VERIFIED`
- `SENSOR_DERIVED`

### 2.17 `supply_point_verification_status`
- `PENDING_REVIEW`
- `VERIFIED`
- `REJECTED`
- `DECOMMISSIONED`

### 2.18 `supply_point_operational_status`
- `ACTIVE`
- `INACTIVE`
- `UNKNOWN`

### 2.19 `supply_point_availability_status`
- `AVAILABLE`
- `LOW`
- `NONE`
- `CLOSED`
- `UNKNOWN`

### 2.20 `order_status`
- `CREATED`
- `ACCEPTED`
- `REJECTED`
- `CANCELLED`
- `DELIVERED`
- `DISPUTED`

### 2.21 `seller_profile_status`
- `ACTIVE`
- `INACTIVE`

### 2.22 `alert_channel`
- `APP`
- `SMS`
- `EMAIL`
- `PUSH`

### 2.23 `alert_delivery_status`
- `PENDING`
- `SENT`
- `FAILED`

### 2.24 `subscription_status`
- `ACTIVE`
- `INACTIVE`
- `CANCELLED`

### 2.24.1 `billing_period`
- `MONTHLY`
- `YEARLY`

### 2.24.2 `subscription_payment_attempt_status`
- `RECORDED`
- `APPLIED`
- `VOIDED`

### 2.25 `plan_id`
- `monitor`
- `protect`
- `pro`

### 2.26 `event_subject_type`
Canonical subject namespaces used by `events.subject_type` (stored as text in Postgres).

- `ACCOUNT`
- `USER`
- `PRINCIPAL`
- `ORG`
- `SITE`
- `RESERVOIR`
- `DEVICE`
- `SUPPLY_POINT`
- `ORDER`

### 2.27 `event_type`
Canonical stable event catalog used by `events.type`:
- `USER_REGISTERED`
- `USER_UPDATED`
- `IDENTIFIER_VERIFIED`
- `PRINCIPAL_UPDATED`
- `SESSION_CREATED`
- `SESSION_REVOKED`
- `PASSWORD_RESET`
- `FIRESTORE_MIRROR_RECONCILE_REQUESTED`
- `DEVICE_REGISTERED`
- `DEVICE_INVENTORY_UNIT_UPSERTED`
- `DEVICE_INVENTORY_PROVISIONING_REQUESTED`
- `DEVICE_INVENTORY_PROVISIONED`
- `DEVICE_INVENTORY_PROVISIONING_FAILED`
- `DEVICE_INVENTORY_DISABLED`
- `DEVICE_INVENTORY_ENABLED`
- `SITE_CREATED`
- `SITE_UPDATED`
- `SITE_DELETED`
- `RESERVOIR_CREATED`
- `RESERVOIR_MONITORING_MODE_CHANGED`
- `RESERVOIR_LEVEL_READING`
- `RESERVOIR_LEVEL_STATE_CHANGED`
- `RESERVOIR_DELETED`
- `RESERVOIR_LOCATION_UPDATED`
- `RESERVOIR_GEOMETRY_UPDATED`
- `RESERVOIR_CAPACITY_UPDATED`
- `RESERVOIR_SENSOR_CALIBRATION_UPDATED`
- `LOW_LEVEL_ALERT`
- `EMPTY_RESERVOIR_ALERT`
- `REFILL_DETECTED`
- `LEAK_SUSPECTED`
- `SUPPLY_ON`
- `SUPPLY_OFF`
- `DEVICE_ATTACHED`
- `DEVICE_DETACHED`
- `DEVICE_OFFLINE`
- `DEVICE_ONLINE`
- `DEVICE_BATTERY_LOW`
- `DEVICE_BATTERY_CRITICAL`
- `DEVICE_STATUS_CHANGED`
- `DEVICE_ATTACH_BY_SERIAL_FAILED`
- `DEVICE_CONFIG_UPDATED`
- `DEVICE_CONFIG_APPLIED`
- `DEVICE_SEEN`
- `FIRMWARE_UPDATE_STATUS`
- `FIRMWARE_RELEASE_CREATED`
- `FIRMWARE_UPDATE_REQUESTED`
- `FIRMWARE_UPDATE_AVAILABLE`
- `FIRMWARE_UPDATE_APPLIED`
- `SUPPLY_POINT_STATUS_UPDATED`
- `SELLER_PROFILE_CREATED`
- `SELLER_PROFILE_UPDATED`
- `SELLER_RESERVOIR_UPDATED`
- `PRICE_RULE_CREATED`
- `DEVICE_TELEMETRY_DROPPED_UNATTACHED`
- `RESERVOIR_SHARE_INVITED`
- `RESERVOIR_SHARE_ACCEPTED`
- `RESERVOIR_SHARE_REJECTED`
- `ORG_INVITE_SENT`
- `ORG_INVITE_ACCEPTED`
- `ORG_MEMBERSHIP_CHANGED`
- `ORG_INVITE_EMAIL_SENT`
- `ORG_INVITE_EMAIL_FAILED`
- `OTP_DELIVERY_REQUESTED`
- `OTP_DELIVERY_SENT`
- `OTP_DELIVERY_FAILED`
- `ACCOUNT_ERASURE_REQUESTED`
- `ACCOUNT_ERASURE_COMPLETED`
- `ORG_ERASURE_REQUESTED`
- `ORG_ERASURE_COMPLETED`
- `TELEMETRY_STUB_MESSAGE`
- `TELEMETRY_INGESTION_ERROR`
- `ACCESS_GRANT_CREATED`
- `ACCESS_GRANT_REVOKED`
- `ALERT_CREATED`
- `NOTIFICATION_PREFERENCES_UPDATED`
- `SUBSCRIPTION_UPGRADED`
- `SUBSCRIPTION_DOWNGRADED`
- `SUBSCRIPTION_EXPIRING_SOON`
- `ORDER_CREATED`
- `ORDER_ACCEPTED`
- `ORDER_REJECTED`
- `ORDER_CANCELLED`
- `ORDER_DELIVERED`
- `ORDER_DISPUTED`
- `REVIEW_SUBMITTED`

Implementation note:
- Store as `text` with a CHECK constraint, or as a Postgres ENUM.
- The stable list must be maintained centrally (avoid per-module drift).

### 2.28 `reservoir_shape`

Reservoir geometry is represented as a **shape discriminator** + **shape parameters** (JSONB) so we can validate strongly in Python without exploding the relational schema into many nullable columns.

- `RECTANGULAR_PRISM` (box tank)
- `VERTICAL_CYLINDER`
- `HORIZONTAL_CYLINDER`
- `CUSTOM` (unknown/irregular; capacity must be provided/overridden)

### 2.29 `reservoir_capacity_source`

Where the current `reservoirs.capacity_liters` came from (single canonical value used for all computations).

- `REPORTED` (user-entered, unverified)
- `DERIVED_FROM_GEOMETRY` (computed from `geometry_shape` + `geometry_params`)
- `ADMIN_OVERRIDE`

### 2.30 `supply_point_enrichment_extraction_type`
- `TAP_STANDPIPE`
- `HAND_PUMP`
- `SOLAR_PUMP`
- `ELECTRIC_PUMP`
- `BUCKET_AND_ROPE`
- `OTHER`
- `UNKNOWN`

### 2.31 `supply_point_enrichment_asset_status`
- `FUNCTIONAL`
- `NOT_FUNCTIONAL`
- `ABANDONED`
- `UNKNOWN`

### 2.32 `supply_point_enrichment_operational_condition`
- `NORMAL`
- `HAS_ISSUES`
- `BROKEN`
- `ABANDONED`
- `UNKNOWN`

### 2.33 `supply_point_enrichment_binary_yn_unknown`
- `YES`
- `NO`
- `UNKNOWN`

### 2.34 `supply_point_enrichment_paid_free_sometimes_unknown`
- `PAID`
- `FREE`
- `SOMETIMES`
- `UNKNOWN`

### 2.35 `supply_point_enrichment_condition_rating`
- `EXCELLENT`
- `GOOD`
- `FAIR`
- `POOR`
- `VERY_POOR`
- `UNKNOWN`

### 2.36 `supply_point_enrichment_governance_effectiveness`
- `EXCELLENT`
- `GOOD`
- `FAIR`
- `POOR`
- `UNKNOWN`

### 2.37 `supply_point_enrichment_yn_sometimes_unknown`
- `YES`
- `NO`
- `SOMETIMES`
- `UNKNOWN`

### 2.38 `supply_point_enrichment_failure_type`
- `NO_WATER_OUTPUT`
- `NOT_WORKING`
- `VALVE_WORN`
- `TAP_DAMAGED`
- `OTHER`
- `UNKNOWN`
- `NOT_APPLICABLE`

### 2.39 `supply_point_enrichment_availability_bucket`
- `H_0_TO_2`
- `H_3_TO_5`
- `H_6_TO_11`
- `H_12_TO_23`
- `H_24`
- `UNKNOWN`

### 2.40 `supply_point_enrichment_water_test_color`
- `CLEAR`
- `TURBID`
- `DIRTY`
- `OTHER`
- `UNKNOWN`
- `NOT_APPLICABLE`

### 2.41 `supply_point_enrichment_water_test_odor`
- `NONE`
- `SLIGHT`
- `STRONG`
- `OTHER`
- `UNKNOWN`
- `NOT_APPLICABLE`

---

## 3. Tables (exact columns + constraints)

### 3.1 `users`

Columns:
- `id uuid primary key`
- `phone_e164 text null`  (E.164, e.g. `+2449...`)
- `email citext null`     (case-insensitive)
- `password_hash text not null`
- `status user_status not null`
- `preferred_language text not null`
- `first_name text null`
- `last_name text null`
- `time_zone text null`
- `phone_verified_at timestamptz null`
- `email_verified_at timestamptz null`
- `metadata jsonb null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`
- `last_login_at timestamptz null`

Constraints / indexes:
  - Registration/contact rules (see decision **D-004**):
    - Household / non-org registration requires **`phone_e164`** (email is optional, both allowed).
    - Org-context verification policy is represented via `users.metadata.activation_policy = ORG_EMAIL_ONLY`:
- Registration requires `phone_e164`; activation follows D-004.
      - Org invite acceptance (`POST /v1/org-invites/accept`) also requires both identifiers and sets `activation_policy = ORG_EMAIL_ONLY` without implying org creator intent.
      - Invite acceptance must not allow identifier collisions to overwrite an existing `ACTIVE` user: if `phone_e164`/`email` are already owned by another `ACTIVE` user, return deterministic `409 IDENTIFIER_ALREADY_IN_USE` (see **D-004**).
- Validation (DB-level checks recommended):
  - `phone_e164` must match E.164: `^\+[1-9]\d{7,14}$` (when not null)
  - `email` basic format check (when not null)
- Unique (partial) indexes:
  - `unique (phone_e164) where phone_e164 is not null`
  - `unique (email) where email is not null`

Implementation note (Postgres):
- Use the `citext` extension for `email` (`create extension if not exists citext;`).

### 3.1.1 Authentication identities (password + third-party)

To support third-party authentication (e.g., Google) without changing the user table shape repeatedly, we model authentication methods as separate identities.

#### `user_auth_identities`

Columns:
- `id uuid primary key`
- `user_id uuid not null references users(id)`
- `provider text not null` (e.g. `PASSWORD`, `GOOGLE`)
- `provider_subject text null` (stable external subject identifier, e.g. Google `sub`)
- `email citext null` (provider-reported email, if any)
- `email_verified bool null`
- `created_at timestamptz not null`
- `last_used_at timestamptz null`

Constraints / indexes:
- `unique (provider, provider_subject)` where `provider_subject is not null`
- `unique (user_id, provider)` (at most one identity per provider per user, v1)
- Index `(user_id)`

Notes:
- For `provider = PASSWORD`, `provider_subject` is null.
- If we support third-party-only users (passwordless accounts), `users.password_hash` must be nullable (or moved into `user_auth_identities` for `provider = PASSWORD`) so OAuth-created users can exist without a password.
- For `provider = GOOGLE`, `provider_subject` stores the Google OIDC `sub` claim (immutable and unique).

### 3.1.2 User sessions (refresh tokens)

To support long-lived logins (mobile) and secure “refresh on reload” (web portal), refresh tokens are modeled as server-side sessions (see decision **D-005**).

#### `user_sessions`

Columns:
- `id uuid primary key`
- `user_id uuid not null references users(id)`
- `client_type text not null` (recommended enum later: `MOBILE|WEB`)
- `refresh_token_hash text not null` (hash of opaque refresh token; never store plaintext)
- `family_id uuid not null` (refresh token rotation family; enables replay detection and family-wide revoke)
- `created_at timestamptz not null`
- `last_used_at timestamptz null`
- `expires_at timestamptz not null`
- `revoked_at timestamptz null`
- `replaced_by_session_id uuid null references user_sessions(id)`
- `metadata jsonb null` (device/app info: device_id, app_version, user_agent, ip hints)

Constraints / indexes:
- Index `(user_id)`
- Index `(refresh_token_hash)` (unique recommended)
- Index `(family_id)`

Notes:
- Refresh tokens are **single-use**: refresh rotates to a new session/token and sets `replaced_by_session_id` on the previous session.
- If a revoked/replaced session token is presented again, revoke the entire family (replay defense).

### 3.1.3 User notification preferences

Stores per-user preferences for alert delivery channels and which reservoir level states should alert.

#### `user_notification_preferences`

Columns:
- `user_id uuid primary key references users(id)`
- `orders_channel_app_enabled bool not null default true`
- `orders_channel_sms_enabled bool not null default false`
- `orders_channel_email_enabled bool not null default false`
- `orders_channel_push_enabled bool not null default true`
- `water_risk_channel_app_enabled bool not null default true`
- `water_risk_channel_sms_enabled bool not null default false`
- `water_risk_channel_email_enabled bool not null default false`
- `water_risk_channel_push_enabled bool not null default true`
- `device_risk_channel_app_enabled bool not null default true`
- `device_risk_channel_sms_enabled bool not null default false`
- `device_risk_channel_email_enabled bool not null default false`
- `device_risk_channel_push_enabled bool not null default false`
- `level_state_full_enabled bool not null default false`
- `level_state_normal_enabled bool not null default false`
- `level_state_low_enabled bool not null default true`
- `level_state_critical_enabled bool not null default true`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Notes:
- Preferences are honored only after subscription gating and identifier verification (D-020/D-023).
- Push notifications are implemented in v1 (D-023) and require at least one active registered push token for delivery.

#### `user_push_tokens`

Stores per-user device push tokens for Firebase Cloud Messaging (FCM). Multiple devices per user are supported.

Columns:
- `id uuid primary key`
- `user_id uuid not null references users(id) on delete cascade`
- `platform text not null` (`ANDROID|IOS`)
- `token text not null` (FCM registration token; treat as secret-ish; never log)
- `status text not null` (`ACTIVE|DISABLED`)
- `disabled_reason text null`
- `created_at timestamptz not null`
- `last_seen_at timestamptz null`
- `disabled_at timestamptz null`

Constraints / indexes:
- `unique (token)`
- Index `(user_id, status)`

#### `push_deliveries`

Idempotent push delivery attempts keyed by `(alert_id, push_token_id)` (at-least-once safe consumers).

Columns:
- `id uuid primary key`
- `alert_id uuid not null references alerts(id) on delete cascade`
- `push_token_id uuid not null references user_push_tokens(id) on delete cascade`
- `status text not null` (`PENDING|SENT|FAILED`)
- `attempt_count int not null default 0`
- `last_attempt_at timestamptz null`
- `next_attempt_at timestamptz null`
- `sent_at timestamptz null`
- `last_error_code text null`
- `last_error_message text null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (alert_id, push_token_id)`
- Index `(status, next_attempt_at)`

### 3.2 `organizations`

Columns:
- `id uuid primary key`
- `name text not null`
- `legal_name text null`
- `country_code text not null`
- `region text null`
- `city text null`
- `primary_contact_user_id uuid null references users(id)`
- `status text not null`  (recommended enum later: `ACTIVE|INACTIVE`)
- `metadata jsonb null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

### 3.3 `principals`

Columns:
- `id uuid primary key`
- `type principal_type not null`
- `user_id uuid null references users(id)`
- `organization_id uuid null references organizations(id)`
- `created_at timestamptz not null`

Constraints / indexes:
- Exactly one of (`user_id`, `organization_id`) is non-null.
- Uniques:
  - `unique (user_id) where user_id is not null`
  - `unique (organization_id) where organization_id is not null`

### 3.3.1 `principal_profiles` (shared profile surface)

Shared “profile” fields for any principal (USER or ORGANIZATION). This avoids duplicating UX-facing
profile columns across `users` and `organizations` while keeping Postgres canonical (Firestore mirrors
may project this for realtime UI later per the mirroring doc).

Canonical identity semantics (v1):
- User display names are derived from `users.first_name` + `users.last_name`.
- Org display names are derived from `organizations.name`.
- Seller display names remain in `seller_profiles.seller_display_name`.

Columns:
- `principal_id uuid primary key references principals(id)`
- `avatar_uri text null`
- `metadata jsonb null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `principal_id` references `principals(id)`; on delete cascade.

### 3.3.2 `platform_settings` (singleton tenant configuration)

Singleton row storing platform-level configuration for turnkey self-host installs (D-063).

Columns:
- `singleton_id boolean primary key default true`
  - Constraint: `CHECK (singleton_id = true)` (enforces singleton semantics).
- `internal_ops_org_id uuid null references organizations(id) on delete set null`
  - Defines the internal ops org container id used by platform admin gating (D-059).
- `allowed_admin_email_domain text not null default 'jila.ai'`
  - Platform admins must have `users.email` ending in this domain.
- `bootstrap_secret_hash text null`
  - Hash of the one-time bootstrap secret (never store plaintext).
- `bootstrap_used_at timestamptz null`
  - When set, bootstrap is complete and cannot be replayed.
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- Primary key on `singleton_id`

### 3.4 `access_grants`

Columns:
- `id uuid primary key`
- `subject_principal_id uuid not null references principals(id)`
- `object_type access_grant_object_type not null`
- `object_id uuid not null`
- `role text not null`  (canonical role set: `OWNER|MANAGER|VIEWER`)
- `granted_by_principal_id uuid null references principals(id)`
- `status access_grant_status not null`
- `created_at timestamptz not null`
- `revoked_at timestamptz null`

Constraints / indexes:
- `unique (subject_principal_id, object_type, object_id)`
- Indexes:
  - `(subject_principal_id)`
  - `(object_type, object_id)`

### 3.5 `tokens`

Columns:
- `id uuid primary key`
- `type token_type not null`
- `subject_principal_id uuid null references principals(id)`
- `target_identifier text null`
- `invite_code text null`  (human-friendly invite code, e.g. `ABCD-EFGH`, for reservoir share invites; D-029)
- `invite_target_phone_e164 text null`  (target phone prefill + anti-theft redemption; D-029)
- `invite_target_email citext null`  (target email prefill + anti-theft redemption; D-029)
- `object_type access_grant_object_type null`
- `object_id uuid null`
- `proposed_role text null`
- `metadata jsonb null` (invite scope and other token-scoped parameters; v1 uses for org/site scopes)
- `token_hash text not null`
- `expires_at timestamptz not null`
- `used_at timestamptz null`
- `revoked_at timestamptz null`
- `created_at timestamptz not null`

Constraints / indexes:
- Indexes:
  - `(type, target_identifier)` (OTP lookup)
  - `(type, subject_principal_id)`
  - `(object_type, object_id)` (invite lookup)
  - `unique (invite_code) where invite_code is not null` (v1: codes are globally unique; recycling is future)

Notes:
- Org invites use `type = INVITE`, `object_type = ORG`, and `target_identifier` (email).
- Invite revocation is represented by `revoked_at` and must prevent redemption and public resolution (`422 INVALID_INVITE`).

### 3.6 `zones`

Columns:
- `id uuid primary key`
- `name text not null`
- `admin_code text null`
- `geometry geography(Polygon, 4326) null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

### 3.7 `sites`

Columns:
- `id uuid primary key`
- `owner_principal_id uuid not null references principals(id)`
- `name text not null`
- `site_type site_type not null`
- `country_code text not null`
- `region text null`
- `city text null`
- `location geography(Point, 4326) null`
- `zone_id uuid null references zones(id)`
- `deleted_at timestamptz null` (soft delete; preserves audit/history)
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Indexes:
- `(owner_principal_id)`
- `(zone_id)`

### 3.7.1 `site_consumption_profiles`

Purpose:
- Stores **per-site** inputs/overrides used to estimate consumption (e.g., household size) for UX such as “days remaining / days of autonomy”.
- This is intentionally keyed by `sites.id` (not `users.id`) because accounts can have multiple sites.

Columns:
- `site_id uuid primary key references sites(id) on delete cascade`
- `schema_version integer not null default 1` (version for the `attributes` shape)
- `household_size integer null`
- `household_size_evidence_type evidence_type null` (must be present when `household_size` is present)
- `daily_consumption_liters_override numeric null` (authoritative liters/day override)
- `daily_consumption_override_evidence_type evidence_type null` (must be present when override is present)
- `attributes jsonb null` (extensible consumption-model inputs; do not store secrets)
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Checks / invariants:
- `schema_version >= 1`
- `household_size > 0` (when set)
- `(household_size is null) == (household_size_evidence_type is null)`
- `daily_consumption_liters_override > 0` (when set)
- `(daily_consumption_liters_override is null) == (daily_consumption_override_evidence_type is null)`

### 3.8 `supply_points`

Columns:
- `id uuid primary key`
- `kind supply_point_kind not null`
- `label text null` (human-facing label for the supply point itself; not a principal profile field)
- `location geography(Point, 4326) not null`
- `zone_id uuid null references zones(id)`
- `verification_status supply_point_verification_status not null`
- `verification_updated_at timestamptz null`
- `created_by_principal_id uuid null references principals(id)`
- `verified_by_principal_id uuid null references principals(id)`
- `rejected_by_principal_id uuid null references principals(id)`
- `rejection_reason text null`
- `operational_status supply_point_operational_status not null`
- `operational_status_updated_at timestamptz null`
- `availability_status supply_point_availability_status not null`
- `availability_updated_at timestamptz null`
- `availability_evidence_type evidence_type null`
- `attributes jsonb null`
- `operator_principal_id uuid null references principals(id)`
- `extraction_type supply_point_enrichment_extraction_type null`
- `has_tank supply_point_enrichment_binary_yn_unknown null`
- `tap_count integer null`
- `has_fence supply_point_enrichment_binary_yn_unknown null`
- `asset_status supply_point_enrichment_asset_status null`
- `operational_condition supply_point_enrichment_operational_condition null`
- `has_breakdown supply_point_enrichment_binary_yn_unknown null`
- `failure_type supply_point_enrichment_failure_type null`
- `hours_per_day numeric null`
- `availability_bucket supply_point_enrichment_availability_bucket null`
- `flow_value_raw numeric null`
- `consumer_count numeric null`
- `hygiene_rating supply_point_enrichment_condition_rating null`
- `drainage_rating supply_point_enrichment_condition_rating null`
- `governance_exists supply_point_enrichment_binary_yn_unknown null`
- `governance_effectiveness supply_point_enrichment_governance_effectiveness null`
- `governance_response supply_point_enrichment_yn_sometimes_unknown null`
- `payment_model supply_point_enrichment_paid_free_sometimes_unknown null`
- `water_test_color supply_point_enrichment_water_test_color null`
- `water_test_odor supply_point_enrichment_water_test_odor null`
- `last_test_date date null`
- `construction_date date null`
- `last_working_date date null`
- `last_rehab_date date null`
- `survey_year integer null`
- `province text null`
- `municipality text null`
- `commune text null`
- `neighborhood text null`
- `source_location geography(Point, 4326) null`
- `source_location_precision_m numeric null`
- `source_location_altitude_m numeric null`
- `normalization_version text null`
- `source_dataset text null`
- `source_record_id text null`
- `source_row_hash text null`
- `raw_record jsonb null`
- `failure_type_other_text_raw text null`
- `notes_raw text null`
- `community_response_raw text null`
- `interviewer_name text null`
- `caretaker_name text null`
- `caretaker_phone text null`
- `coordinator_name text null`
- `coordinator_phone text null`
- `funder_raw text null`
- `implementer_raw text null`
- `normalization_notes jsonb null`
- `admin_enrichment_created_at timestamptz null`
- `admin_enrichment_updated_at timestamptz null`
- `deleted_at timestamptz null` (soft delete / decommission; preserves audit/history)
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Indexes:
- Geo index on `location` (GiST)
- Geo index on `source_location` (GiST)
- `(zone_id)`
- `(verification_status)`
- `(operational_status)`
- `(availability_status)`
- unique partial `(source_dataset, source_record_id)` where both are non-null (idempotent re-imports).
- index `(province)` and `(municipality)`.

Checks:
- `tap_count >= 0` when present.
- `hours_per_day` bounded to `[0, 24]` when present.
- `survey_year >= 1900` when present.

### 3.9 `reservoirs`

Columns:
- `id uuid primary key`
- `site_id uuid null references sites(id)`
- `owner_principal_id uuid not null references principals(id)`
- `supply_point_id uuid null references supply_points(id)`
- `name text null` (display label; present in API contract v1)
- `seller_availability_status seller_availability_status not null`
- `seller_availability_updated_at timestamptz null`
- `reservoir_type reservoir_type not null`
- `mobility reservoir_mobility not null`
- `capacity_liters numeric not null`
- `capacity_source reservoir_capacity_source not null default 'REPORTED'`
- `capacity_reported_liters numeric null` (optional “what the user told us”, kept for transparency)
- `capacity_updated_at timestamptz null`
- `geometry_shape reservoir_shape null`
- `geometry_params jsonb null` (shape-dependent dimensions; validated by the API)
- `geometry_updated_at timestamptz null`
- `safety_margin_pct numeric not null default 20`
- `monitoring_mode monitoring_mode not null`
- `location geography(Point, 4326) null`
- `height_mm integer null` (reservoir internal height in millimeters; used for default device calibration)
- `sensor_empty_distance_mm integer null` (device reservoirs; distance reading when tank is “empty”)
- `sensor_full_distance_mm integer null` (device reservoirs; distance reading when tank is “full”)
- `full_threshold_pct numeric(5,2) null` (user-configured; enter FULL when level_pct >= this)
- `low_threshold_pct numeric(5,2) null` (user-configured; enter LOW when level_pct <= this)
- `critical_threshold_pct numeric(5,2) null` (user-configured; enter CRITICAL when level_pct <= this)
- `level_state text null` (derived current state; one of `FULL|NORMAL|LOW|CRITICAL`)
- `level_state_updated_at timestamptz null` (UTC timestamp when `level_state` last changed)
- `location_updated_at timestamptz null`
- `deleted_at timestamptz null` (soft delete; preserves audit/history)
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Notes (v1):
- Device-derived readings require calibration. If `sensor_empty_distance_mm` and `sensor_full_distance_mm` are both null
  but `height_mm` is set, the backend derives default calibration for telemetry ingestion: `empty=height_mm`, `full=0`.
  If calibration is missing and `height_mm` is null, telemetry is stored but no derived readings are produced
  (`TELEMETRY_INGESTION_ERROR` with `error=CALIBRATION_MISSING`).

Invariants (v1, behavioral; enforced by service logic):
- Reservoir container hierarchy is single-valued: **reservoirs always belong to a site**.
- `POST /v1/reservoirs` may omit `site_id`; the service assigns the account's default org site and persists a non-null `reservoirs.site_id`.
  - Organization: org reservoirs must have a non-null `site_id` (Decision D-038).
- Ownership is derived from the site container:
  - `reservoirs.owner_principal_id` is derived from `sites.owner_principal_id` for the assigned site.
  - The API must not accept `owner_principal_id` from clients.

Indexes:
- `(owner_principal_id)`
- `(site_id)`
- Geo index on `(location)` if queried.

Checks / invariants (recommended):
- `capacity_liters > 0`
- `capacity_reported_liters > 0` (when not null)
- `height_mm > 0` (when not null)
- If `geometry_shape is null` then `geometry_params must be null` (keep the contract tight).
- If `geometry_shape = 'CUSTOM'` then `capacity_source != 'DERIVED_FROM_GEOMETRY'` (no fake precision).

Geometry contract (canonical; units + formulas):

- **Units**: all geometry dimensions are **millimeters** (`*_mm`) in `geometry_params`.
- **Validation**: for non-`CUSTOM` shapes, all required fields must exist and be positive integers; unknown fields are rejected (API-level).
- **Capacity derivation**: when `capacity_source = DERIVED_FROM_GEOMETRY`, compute:
  - `capacity_liters = round(volume_mm3 / 1_000_000.0, 2)`
  - where `volume_mm3` depends on shape:

`RECTANGULAR_PRISM`
- `geometry_params`:
  - `length_mm` (int, >0)
  - `width_mm` (int, >0)
  - `height_mm` (int, >0)
- \(volume\_{mm^3} = length\_{mm} \times width\_{mm} \times height\_{mm}\)

`VERTICAL_CYLINDER`
- `geometry_params`:
  - `radius_mm` (int, >0)
  - `height_mm` (int, >0)
- \(volume\_{mm^3} = \pi \times radius\_{mm}^2 \times height\_{mm}\)

`HORIZONTAL_CYLINDER`
- `geometry_params`:
  - `radius_mm` (int, >0)
  - `length_mm` (int, >0)
- \(volume\_{mm^3} = \pi \times radius\_{mm}^2 \times length\_{mm}\)

`CUSTOM`
- `geometry_params` may be null or may store arbitrary metadata for reference, but must not be used to derive capacity.

### 3.10 `devices`

Columns:
- `id uuid primary key`
- `device_id text not null` (canonical MQTT topic identity; stored uppercase, length may vary)
- `name text null` (optional display label; present in API contract v1)
- `inventory_unit_id uuid null references device_inventory_units(id)` (links operational device to physical inventory unit; Option B registry)
- `device_type device_type not null`
- `firmware_version text null`
- `imei text null`
- `iccid text null`
- `imsi text null`
- `msisdn text null`
- `carrier_name text null`
- `apn text null`
- `last_rssi_dbm smallint null`
- `last_rsrp_dbm smallint null`
- `last_rsrq_db smallint null`
- `last_sinr_db smallint null`
- `reservoir_id uuid null references reservoirs(id)`
- `last_seen_at timestamptz null`
- `last_battery_pct numeric null`
- `status device_status not null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Notes (v1):
- Devices attach to reservoirs (not to sites). Site context is implied via `devices.reservoir_id → reservoirs.site_id`.
- `devices.reservoir_id` is nullable by design:
  - Devices may exist in an unattached state (inventory/provisioning).
  - Telemetry and derived readings are only produced when a device is attached to a reservoir (unattached telemetry is dropped; see D-007 + architecture telemetry flow).
  - When the linked inventory unit is set to `DISABLED`, the backend forces a detach and marks the device `status=INACTIVE`.

Constraints / indexes:
- `unique (device_id)`
- `unique (inventory_unit_id) where inventory_unit_id is not null` (enforces 1:1 mapping: one operational device per inventory unit)
- `unique (reservoir_id) where reservoir_id is not null` (enforces 1:1 pairing in v1)

Checks (recommended):
- `imei` length 14–16 digits (implementation-dependent) when not null
- `iccid` length 18–22 digits when not null
- `last_rssi_dbm` and friends within reasonable ranges when not null

### 3.10.a `device_inventory_units` (physical inventory registry; canonical list of owned devices)

Purpose:
- Stores the canonical list of **physical units** that Jila owns/sells (serial + provisioning metadata).
- This table is distinct from `devices` (operational state used for telemetry, pairing, config, and firmware) per Decision **D-052**.

Columns:
- `id uuid primary key`
- `serial_number text not null` (human-facing; normalized to uppercase; format per Decision **D-057**)
- `device_id text not null` (MQTT identity; MAC-derived; normalized to uppercase; topic identity per device protocol)
- `cert_thumbprint_sha1 char(40) null` (Azure ThumbprintMatch; uppercase hex; v1: single thumbprint per unit; required when `provisioning_status=PROVISIONED`)
- `provisioning_status text not null` (recommended enum later: `PENDING|PROVISIONED|DISABLED`)
- `provisioned_at timestamptz null`
- `last_provision_error_code text null`
- `last_provision_error_message text null`
- `metadata jsonb null` (sales/catalog hooks and other non-secret attributes; Decision **D-058**)
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (serial_number)`
- `unique (device_id)`
- Recommended CHECK constraints:
  - Serial format (D-057): `serial_number ~ '^JL-[A-Z0-9]{6}$'`
  - Thumbprint hex: `cert_thumbprint_sha1 ~ '^[0-9A-F]{40}$'`
  - Provisioned implies thumbprint: `(provisioning_status != 'PROVISIONED') OR (cert_thumbprint_sha1 IS NOT NULL)`

Notes:
- `metadata` must not contain secrets (cert material, private keys); store only non-sensitive commercial descriptors.
- Inventory unit creation and Azure MQTT client provisioning are performed by an admin-only backend pipeline (Decision **D-053**).

### 3.10.1 `device_telemetry_messages` (raw JSON payload history)

Stores the raw JSON payload from device telemetry (append-only). This supports evolving payload keys without schema churn.

Narrative explanation:
This table is the system’s “flight recorder” for device communication. It stores exactly what the device sent (as JSON), together with the server receive time and the device sequence number. We keep it so we can audit disputes, diagnose device behavior, and re-derive metrics later if our derivation logic changes.

Columns:
- `id bigint primary key generated always as identity`
- `device_id uuid not null references devices(id)`
- `mqtt_client_id text not null`
- `schema_version integer not null`
- `seq bigint not null`  (device monotonic sequence; required for v1 dedupe)
- `recorded_at timestamptz not null`
- `received_at timestamptz not null`
- `payload jsonb not null`

Indexes:
- `(device_id, recorded_at desc)`
- `(mqtt_client_id, recorded_at desc)`
- `(device_id, schema_version)`

Idempotency (required; see decision D-007):
- `unique (mqtt_client_id, seq)`

Checks (recommended):
- `schema_version > 0`

### 3.10.2 Firmware update tables

#### `firmware_releases`

Metadata for firmware binaries stored in blob storage.

Columns:
- `id uuid primary key`
- `version text not null` (semantic version string, e.g. `1.2.3`)
- `blob_uri text not null` (pointer to blob storage)
- `sha256_hex char(64) not null`
- `size_bytes bigint not null`
- `notes text null`
- `created_by_principal_id uuid null references principals(id)`
- `created_at timestamptz not null`

Constraints / indexes:
- `unique (version)`
- Index `(created_at desc)`

#### `firmware_update_jobs`

Tracks device-targeted update requests and results.

Naming convention:
- DB primary key column is `id`.
- API/event payloads refer to this identifier as `job_id`.

Columns:
- `id uuid primary key`
- `device_id uuid not null references devices(id)`
- `firmware_release_id uuid not null references firmware_releases(id)`
- `config_version integer not null`
- `status text not null` (recommended enum: `PENDING|PUBLISHED|APPLIED|FAILED|CANCELLED`)
- `mqtt_queue_id text not null`  (correlation ID required)
- `requested_by_principal_id uuid null references principals(id)`
- `requested_at timestamptz not null`
- `published_at timestamptz null`
- `applied_at timestamptz null`
- `failed_at timestamptz null`
- `failure_reason text null`
- `updated_at timestamptz not null`

Indexes:
- `(device_id, requested_at desc)`
- `(status, requested_at desc)`
- `(config_version)`
- `(updated_at desc)`

### 3.10.3 Device configuration tables (desired vs applied)

#### `device_config_desired`

The current desired config per device **and per config type** (latest state). This supports independent
configs such as `operation`, `network`, `location`, etc.

Primary key:
- `(device_id, config_type)`

Core columns:
- `device_id uuid not null references devices(id)`
- `config_type text not null` (enum-like: `operation|ultrasonic|network|location|firmware`)
- `config_version integer not null`
- `mqtt_queue_id text not null` (correlation ID required)
- `updated_by_principal_id uuid null references principals(id)`
- `updated_at timestamptz not null`

Typed columns:
- Per-type typed columns are stored in the same row and are validated by DB CHECK constraints.
- Secrets (e.g., WiFi passwords, MQTT passwords) may be present in `network_*` columns; do not mirror these to Firestore.

Constraints (recommended):
- `config_version > 0`
- `mqtt_queue_id` non-empty
- Type-specific “when provided” checks (e.g., operation threshold ordering when all three battery thresholds are present)
- Do **not** require all fields for a type in v1: desired configs may be sparse (delta updates) and are published as sparse MQTT payloads.

#### `device_config_applied`

The latest config state the device reports as applied, per device **and per config type**.

Primary key:
- `(device_id, config_type)`

Core columns:
- `device_id uuid not null references devices(id)`
- `config_type text not null`
- `applied_config_version integer null` (null when no successful apply has been observed yet)
- `applied_at timestamptz null` (null when no successful apply has been observed yet)
- `mqtt_queue_id text null`

Typed snapshot columns:
- The applied row may store a snapshot of the applied config in typed columns (copied from desired on success ACK)
  so applied state remains stable even if desired changes later.

ACK metadata (recommended):
- `last_ack_mqtt_queue_id text null`
- `last_ack_success boolean null`
- `last_ack_status text null`
- `last_ack_message text null`
- `last_ack_received_at timestamptz null`
- `last_ack_seq bigint null`

#### History for config changes
History is recorded via `events` (recommended event types: `DEVICE_CONFIG_UPDATED`, `DEVICE_CONFIG_APPLIED`, `DEVICE_SEEN`) to avoid extra history tables in v1.

### 3.11 `reservoir_readings`

Columns:
- `id bigint primary key generated always as identity`
- `reservoir_id uuid not null references reservoirs(id)`
- `device_id uuid null references devices(id)`
- `source reading_source not null`
- `telemetry_message_id bigint null references device_telemetry_messages(id)` (traceability to raw payload, when device-sourced)
- `device_seq bigint null` (copied from device telemetry `seq`; required when `source = DEVICE` for ordering/dedupe)
- `raw_sample_count integer null` (device-sourced; number of valid raw samples used)
- `raw_mean numeric(10,2) null` (device-sourced; mean of valid raw samples in **mm**)
- `raw_stddev numeric(10,2) null` (device-sourced; std dev of valid raw samples in **mm**)
- `level_pct numeric(5,2) not null`
- `volume_liters numeric(12,2) not null` (derived at ingestion)
- `battery_pct numeric(5,2) null`
- `submitted_by_principal_id uuid null references principals(id) on delete set null` (manual readings; audit + idempotency scope)
- `client_idempotency_key text null` (optional; from `Idempotency-Key` header)
- `idempotency_request_hash text null` (stable hash of request payload; conflict detection)
- `recorded_at timestamptz not null`
- `created_at timestamptz not null`

Narrative explanation:
This table is the queryable history that powers charts, exports, and analytics. Each row represents one interpreted reading (level and volume) at a point in time. Unlike `events`, which is a generic “something happened” log, `reservoir_readings` is optimized for time-series queries such as “show me the last 30 days of readings for this reservoir”.

Indexes:
- `(reservoir_id, recorded_at desc)` (latest queries)
- Idempotency (required for device-sourced readings; see decision D-007):
  - `unique (device_id, device_seq) where source = 'DEVICE'`
- Idempotency (recommended for manual readings; offline queue safety):
  - `unique (reservoir_id, submitted_by_principal_id, client_idempotency_key) where source = 'MANUAL' and client_idempotency_key is not null`

Checks (recommended):
- `level_pct` between 0 and 100
- `battery_pct` between 0 and 100 (when not null)
- `raw_sample_count >= 0` (when not null)
- `raw_stddev >= 0` (when not null)

### 3.12 `reservoir_price_rules`

Columns:
- `id uuid primary key`
- `reservoir_id uuid not null references reservoirs(id)`
- `min_volume_liters numeric not null` (v1 contract uses explicit bounds)
- `max_volume_liters numeric not null` (v1 contract uses explicit bounds)
- `base_price_per_liter numeric(12,6) not null`
- `delivery_fee_flat numeric(12,2) null`
- `currency char(3) not null`

Indexes:
- `(reservoir_id, currency)`

Constraints:
- Non-overlapping volume ranges per `(reservoir_id, currency)`.
  - Preferred: exclusion constraint using `numrange(min_volume_liters, max_volume_liters, '[]')`.
  - If the deployment environment does not allow required extensions (e.g. `btree_gist` on managed Postgres),
    enforce non-overlap with a DB trigger guarded by an advisory transaction lock per `(reservoir_id, currency)`.

### 3.13 `seller_profiles`

Purpose:
- This table represents **seller-mode eligibility/gating** for a principal (ACTIVE/INACTIVE), not general identity.
- The principal’s canonical display identity is stored in `principal_profiles`.

Columns:
- `principal_id uuid primary key references principals(id)`
- `status seller_profile_status not null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

### 3.14 `orders`

Columns:
- `id uuid primary key`
- `order_code text null` (human-friendly stable identifier; format: `ORD-` + 12 chars; unique)
- `buyer_principal_id uuid not null references principals(id)`
- `target_reservoir_id uuid null references reservoirs(id)`
- `seller_reservoir_id uuid not null references reservoirs(id)`
- `requested_volume_liters numeric(12,2) not null`
- `price_quote_total numeric(12,2) not null`
- `currency char(3) not null`
- `status order_status not null`
- `client_idempotency_key text null` (optional client retry key; from `Idempotency-Key` header)
- `idempotency_request_hash text null` (stable hash of the create-order request for conflict detection)
- `created_at timestamptz not null`
- `updated_at timestamptz not null`
- `accepted_at timestamptz null`
- `cancelled_at timestamptz null`
- `buyer_confirmed_delivery_at timestamptz null`
- `buyer_confirmed_delivery_at_client timestamptz null` (client-asserted; untrusted; optional)
- `seller_confirmed_delivery_at timestamptz null`
- `seller_confirmed_delivery_at_client timestamptz null` (client-asserted; untrusted; optional)
- `buyer_confirmed_volume_liters numeric null`
- `seller_confirmed_volume_liters numeric null`
- `buyer_delivery_note text null`
- `seller_delivery_note text null`
- `delivered_at timestamptz null`

Indexes:
- `(buyer_principal_id, created_at desc)`
- `(seller_reservoir_id, created_at desc)`
- `(status, created_at desc)`
- `unique (buyer_principal_id, client_idempotency_key) where client_idempotency_key is not null`
- `unique (order_code)`

Notes:
- v1 API treats `order_code` as required for client UX; some rows may be null until backfilled.
- Delivery confirmation “first-write-wins” per party is enforced by service logic (conditional checks + deterministic `409 DELIVERY_CONFIRMATION_ALREADY_SET`) in v1.
  - Future hardening option: add a dedicated typed confirmation table with per-side uniqueness constraints if we need DB-level enforcement.

### 3.15 `reviews`

Columns:
- `id uuid primary key`
- `order_id uuid not null references orders(id)`
- `reviewer_principal_id uuid not null references principals(id)`
- `rating smallint not null` (1–5)
- `comment text null`
- `created_at timestamptz not null`

Constraints:
- `unique (order_id)` (at most one review per order in v1)
- `rating` check: between 1 and 5

### 3.16 `events`

Narrative explanation:
This table is the system’s central “something happened” stream. We write one `events` row in the same database transaction as the primary state change (for example inserting a `reservoir_readings` row), so that downstream processes can reliably react to changes without missing anything. We do not query `events` for time-series charts; we use it for audit trails, integration triggers (such as Firestore mirroring), and replayable processing.

Columns:
- `id uuid primary key`
- `seq bigint generated always as identity` (monotonic order for outbox consumption; do not use as a public identifier)
- `type text not null`  (see `event_type` list)
- `subject_type event_subject_type not null`
- `subject_id uuid not null`
- `data jsonb not null`
- `created_at timestamptz not null`

Indexes:
- `unique (seq)`
- `(seq)`
- `(subject_type, subject_id, created_at desc)`
- `(type, created_at desc)`

Outbox consumption (v1, canonical):
- Consumers must read in `seq` order and checkpoint progress. See `event_consumers` below.

### 3.16.1 `event_consumers` (outbox checkpoints)

Tracks per-consumer progress through the ordered `events` stream.

Narrative explanation:
Each consumer keeps its own “bookmark” into the `events` stream using `last_seq`. When a consumer restarts, it reads from the last saved sequence number and replays any events it has not confirmed yet. This is why consumer logic must be idempotent: the same event can be processed more than once after a crash, and the result must still be correct.

Columns:
- `consumer_name text primary key` (e.g. `firestore_mirror`, `alerts_worker`)
- `last_seq bigint not null default 0`
- `updated_at timestamptz not null`

Notes:
- Consumer logic must be idempotent; `last_seq` is advanced only after successfully handling all events up to that `seq`.

### 3.16.2 `otp_deliveries` (OTP send idempotency)

Ensures OTP delivery is idempotent per `(token_id, channel)` (decision **D-012**).

Columns:
- `id uuid primary key`
- `token_id uuid not null references tokens(id)`
- `account_id uuid null` (account/user UUID for event subjects)
- `channel text not null` (`SMS|EMAIL`)
- `status text not null` (`PENDING|SENT|FAILED`)
- `attempt_count int not null default 0`
- `last_attempt_at timestamptz null`
- `next_attempt_at timestamptz null` (retry backoff)
- `sent_at timestamptz null`
- `last_error_code text null`
- `last_error_message text null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (token_id, channel)`
- Index: `(status, next_attempt_at)`

Operational note (worker scheduling):
- `next_attempt_at` is the canonical persisted “retry backoff” clock for OTP delivery. The worker should
  avoid fixed-interval polling and instead sleep until the next due attempt (bounded) per **D-012**.

### 3.16.3 `org_invite_deliveries` (org invite email send idempotency)

Ensures organization invite email delivery is idempotent per `invite_token_id` (decision **D-012**).

Columns:
- `id uuid primary key`
- `invite_token_id uuid not null references tokens(id)`
- `org_id uuid not null`
- `target_email text not null`
- `status text not null` (`PENDING|SENT|FAILED`)
- `attempt_count int not null default 0`
- `last_attempt_at timestamptz null`
- `next_attempt_at timestamptz null` (retry backoff)
- `sent_at timestamptz null`
- `last_error_code text null`
- `last_error_message text null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (invite_token_id)`
- Index: `(status, next_attempt_at)`

### 3.16.4 `password_reset_confirmation_deliveries` (password reset confirmation email idempotency)

Ensures password reset confirmation delivery is idempotent per `(event_id, channel)` and safe under retries.

Columns:
- `id uuid primary key`
- `event_id uuid not null references events(id)`
- `user_id uuid not null references users(id)`
- `channel text not null` (`EMAIL|SMS`)
- `target_identifier text not null` (email or phone identifier used for delivery)
- `status text not null` (`PENDING|SENT|FAILED`)
- `attempt_count int not null default 0`
- `last_attempt_at timestamptz null`
- `next_attempt_at timestamptz null` (retry backoff)
- `sent_at timestamptz null`
- `last_error_code text null`
- `last_error_message text null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (event_id, channel)`
- Index: `(status, next_attempt_at)`

### 3.16.5 `alert_sms_deliveries` (alert SMS send idempotency)

Ensures SMS delivery for `ALERT_CREATED` (`channel=SMS`) is idempotent per alert and safe under retries.

Columns:
- `id uuid primary key`
- `alert_id uuid not null references alerts(id)`
- `user_id uuid not null references users(id)`
- `target_phone_e164 text not null` (verified destination phone)
- `status text not null` (`PENDING|SENT|FAILED`)
- `attempt_count int not null default 0`
- `last_attempt_at timestamptz null`
- `next_attempt_at timestamptz null` (retry backoff)
- `sent_at timestamptz null`
- `last_error_code text null`
- `last_error_message text null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (alert_id)`
- Index: `(status, next_attempt_at)`

### 3.16.6 `alert_email_deliveries` (alert email send idempotency)

Ensures email delivery for `ALERT_CREATED` (`channel=EMAIL`) is idempotent per alert and safe under retries.

Columns:
- `id uuid primary key`
- `alert_id uuid not null references alerts(id)`
- `user_id uuid not null references users(id)`
- `target_email text not null` (verified destination email)
- `status text not null` (`PENDING|SENT|FAILED`)
- `attempt_count int not null default 0`
- `last_attempt_at timestamptz null`
- `next_attempt_at timestamptz null` (retry backoff)
- `sent_at timestamptz null`
- `last_error_code text null`
- `last_error_message text null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (alert_id)`
- Index: `(status, next_attempt_at)`

### 3.17 `alerts`

Columns:
- `id uuid primary key`
- `owner_principal_id uuid not null references principals(id)`
- `user_id uuid not null references users(id)` (recipient / delivery context)
- `read_by_user_id uuid null references users(id)` (audit)
- `resolved_by_user_id uuid null references users(id)` (audit)
- `event_id uuid not null references events(id)`
- `channel alert_channel not null`
- `delivery_status alert_delivery_status not null`
- `created_at timestamptz not null`
- `sent_at timestamptz null`
- `read_at timestamptz null`
- `resolved_at timestamptz null` (when set, alert is cleared from active client feed)

Indexes:
- `(owner_principal_id, created_at desc)`
- `(delivery_status)`
- Partial: `(owner_principal_id, created_at desc) WHERE resolved_at IS NULL AND read_at IS NULL` (unread feed / badges)

Implementation note:
- `created_at` is required for stable pagination ordering.
 - v1 clients consume the active feed; resolved alerts are retained for audit but excluded from `/v1/accounts/{account_id}/alerts`.

### 3.17.1 `device_health_states` (latest device health state)

Tracks the **current** device health issue state for state-transition based alerting (latest-state table).
History remains in `events`.

Columns:
- `device_id uuid not null references devices(id)`
- `reason text not null` (e.g. `NO_VALID_ULTRASONIC_SAMPLES`)
- `is_active bool not null`
- `trigger_event_id uuid null references events(id)` (event that opened the current incident)
- `opened_at timestamptz null`
- `resolved_at timestamptz null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `primary key (device_id, reason)`

### 3.18 `plans`

Columns:
- `id plan_id primary key`
- `name text not null`
- `description text null`
- `config jsonb not null`
- `currency char(3) not null` (ISO 4217)
- `monthly_price numeric(12,2) not null`
- `yearly_price numeric(12,2) not null`
- `monthly_credits_grant int not null` (abstract units; SB-012)
- `yearly_credits_grant int not null` (abstract units; SB-012)
- `limits jsonb not null` (quantitative limits; enforced server-side; SB-006)

Seed data (v1, required):
- The following `plans.id` rows MUST exist: `monitor`, `protect`, `pro` (see enum `plan_id`).
- Implementations may upsert these rows idempotently on first use to prevent fresh DBs from breaking
  endpoints that must always return a subscription summary (e.g. `GET /v1/me`, `GET /v1/accounts/{account_id}/subscription`).

Config schema (v1, canonical):
- `config.features`: object mapping `feature_key` → boolean.
- `feature_key` is a stable string; missing keys are treated as `false`.
- Alerts gating uses decision **D-023** keys: `alerts.<alert_kind>.<channel>` where `<channel> ∈ {APP,SMS,EMAIL}`.
- Analytics gating uses:
  - `analytics.view`
  - `analytics.export`

Example (canonical v1 differentiation):

| Tier | Purpose | Features | Limits |
| :--- | :--- | :--- | :--- |
| **`monitor`** | Basic visibility | APP alerts, Analytics View | 1 site, 2 members |
| **`protect`** | Multi-site | APP/PUSH/EMAIL alerts, Export | 5 sites, 10 members |
| **`pro`**     | Fleet | All above + SMS alerts | Unlimited (999) |

```json
{
  "features": {
    "alerts.reservoir_level_state.APP": true,
    "alerts.reservoir_level_state.SMS": false,
    "alerts.reservoir_level_state.EMAIL": false,
    "analytics.view": true
  }
}
```

### 3.19 `subscriptions`

Columns:
- `id uuid primary key`
- `account_principal_id uuid not null references principals(id)`
- `plan_id plan_id not null references plans(id)`
- `status subscription_status not null`
- `billing_period text not null` (see enum `billing_period`)
- `starts_at timestamptz null`
- `ends_at timestamptz null`
- `grace_until timestamptz null`
- `created_at timestamptz not null`

Indexes:
- `(account_principal_id)`

Notes:
- `starts_at/ends_at` are treated as the authoritative current period boundaries (SB-002).
- Trial periods are plan-agnostic: `ends_at` may be set to `now() + trial_days` at onboarding or plan change
  (default 14, override 0–90; SB-017).

### 3.20 `subscription_payment_attempts`

Auditable record of manual payment entries and (later) provider callbacks.

Columns:
- `id uuid primary key`
- `account_principal_id uuid not null references principals(id)`
- `provider text null` (null for manual entry MVP)
- `reference text null`
- `status text not null` (see enum `subscription_payment_attempt_status`)
- `idempotency_key text not null`
- `raw_payload jsonb not null`
- `created_at timestamptz not null`

Constraints / indexes:
- unique `(account_principal_id, idempotency_key)` (SB-005)
- `(account_principal_id, created_at desc)`

### 3.21 `account_credit_ledger`

Append-only credit ledger for abstract credit units (SB-008/SB-012).

Columns:
- `id uuid primary key`
- `account_principal_id uuid not null references principals(id)`
- `payment_attempt_id uuid null references subscription_payment_attempts(id)`
- `delta_credits int not null`
- `reason text not null`
- `created_at timestamptz not null`

Constraints / indexes:
- `(account_principal_id, created_at desc)`

Invariants:
- Credits must never go negative (SB-013). Enforce via transaction-safe checks when inserting debits.

### 3.22 Analytics intelligence tables

These tables back the post-v1 analytics module (`app/modules/analytics/`) and are intentionally typed + index-backed.

#### 3.22.1 `device_location_points`

Derived GPS points extracted from raw telemetry payloads.

Columns:
- `id bigint primary key generated always as identity`
- `device_id uuid not null references devices(id)`
- `telemetry_message_id bigint not null references device_telemetry_messages(id)`
- `seq bigint not null`
- `recorded_at timestamptz not null`
- `lat double precision not null`
- `lng double precision not null`
- `speed_kmh double precision null`
- `course_degrees double precision null`
- `zone_id uuid null references zones(id)`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (device_id, telemetry_message_id)` (idempotent extraction)
- `(device_id, recorded_at desc)`
- `(zone_id, recorded_at desc)`

#### 3.22.2 `mobile_stop_episodes`

Stop episodes classified from movement + volumetric deltas.

Columns:
- `id bigint primary key generated always as identity`
- `device_id uuid not null references devices(id)`
- `start_at timestamptz not null`
- `end_at timestamptz not null`
- `duration_seconds int not null`
- `centroid geography(Point, 4326) not null`
- `zone_id uuid null references zones(id)`
- `volume_delta_liters numeric null`
- `event_type text not null` (`DELIVERY|REFILL|DOWNTIME|UNKNOWN`)
- `confidence text not null` (`HIGH|MEDIUM|LOW`)
- `inputs_version int not null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (device_id, start_at, end_at)` (bounded idempotency)
- `(device_id, start_at desc)`
- `(zone_id, start_at desc)`

#### 3.22.3 `mobile_places`

Significant places clustered from repeated stops.

Columns:
- `place_id uuid primary key`
- `device_id uuid not null references devices(id)`
- `centroid geography(Point, 4326) not null`
- `zone_id uuid null references zones(id)`
- `place_type text not null` (`BASE|REFILL_DEPOT|CLIENT_CLUSTER|UNKNOWN`)
- `first_seen_at timestamptz not null`
- `last_seen_at timestamptz not null`
- `inputs_version int not null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Indexes:
- `(device_id, last_seen_at desc)`
- `(zone_id, place_type)`

#### 3.22.4 `stationary_hourly_series`

Hourly stationary rollup with inflow/demand decomposition.

Columns:
- `reservoir_id uuid not null references reservoirs(id)`
- `hour_start timestamptz not null`
- `median_level_pct numeric null`
- `median_volume_liters numeric null`
- `smoothed_volume_liters numeric null`
- `inflow_liters numeric not null`
- `demand_liters numeric not null`
- `inputs_version int not null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `primary key (reservoir_id, hour_start)`
- `(hour_start desc)`

#### 3.22.5 `stationary_supply_events`

Inferred contiguous stationary supply episodes.

Columns:
- `id bigint primary key generated always as identity`
- `reservoir_id uuid not null references reservoirs(id)`
- `start_at timestamptz not null`
- `end_at timestamptz not null`
- `inflow_liters numeric not null`
- `confidence text not null` (`HIGH|MEDIUM|LOW`)
- `inputs_version int not null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- `unique (reservoir_id, start_at, end_at)`
- `(reservoir_id, start_at desc)`

#### 3.22.6 Windowed metrics tables

Scope-specific metrics snapshots:
- `reservoir_metrics_windows`
- `site_metrics_windows`
- `org_metrics_windows`
- `zone_metrics_windows`

Shared columns:
- scope FK (`reservoir_id|site_id|org_principal_id|zone_id`)
- `window_label text not null` (`24h|7d|30d|custom`)
- `window_start timestamptz not null`
- `window_end timestamptz not null`
- Stationary metrics (`runout_hours`, `runout_prob`, `autonomy_days_est`, `supply_hours`, `supply_fragmentation_index`)
- Stationary extensions (`mean_supply_duration_hours`, `daily_supply_coverage`, `intermittence_severity_index`, `demand_liters`)
- Stationary behavior metrics (`elasticity_near_empty`, `suppressed_demand_index`)
- Mobile metrics (`deliveries_count`, `delivered_liters`, `liters_loaded`, `liters_per_km`, `refill_time_minutes`, `refill_load_rate_l_per_min`, `downtime_hours`, `mobile_nrw_liters`)
- Integrated metrics (`pipeflow_liters`, `truckflow_liters`, `resilience_ratio`)
- Data quality metadata (`data_gap_hours`, `confidence`, `inputs_version`, `metric_version`)
- `computed_at timestamptz not null`
- `created_at timestamptz not null`
- `updated_at timestamptz not null`

Constraints / indexes:
- Scope composite PK on `(scope_id, window_label, window_start, window_end)`
- `confidence` constrained to `HIGH|MEDIUM|LOW`
- `window_end > window_start`
- `computed_at desc` index on each table

Notes:
- These are read-model tables, not immutable history tables.
- Recompute/backfill is deterministic via `inputs_version` + `metric_version`.

---

## 4. Model gaps / follow-ups (keep small and explicit)

1. **PostGIS vs numeric lat/lng**
   - **DECIDED (D-006)**: PostGIS `geography(Point, 4326)` is canonical.

2. **`alerts.created_at`**
   - Architecture lists `sent_at`/`read_at`; we recommend adding `created_at` for pagination ordering.

3. **`organizations.status`**
   - Architecture proposes `ACTIVE|INACTIVE`; formalize as enum if we want stricter DB validation.
